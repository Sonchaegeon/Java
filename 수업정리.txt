자바는 프로그래밍 언어이다. 
고급언어에 해당.
객체지향 언어.

프로그래밍 ->컴파일러 -> 기계어 실행

자바 가상 머신 JVM
OS별로 JVM이 존재한다. 
자바프로그램  순서 컴파일러 -> 바이트 코드 -> JVM -> OS

JDK > JRE > JVM
JDK = JRE + 개발 도구
- 자바 프로그램 개발하고 실행하기 위해 반드시 설치
JRE = JVM + 표준 클래스 라이브러리
- 자바 프로그램을 실행만 할 경우 설치

프로그램 작성과 실행
프로젝트 생성 -> 자바 프로그래밍 코딩(*.java) -> 바이트 코드 생성(*.class) -> 실행
javac.exe java.exe

주석
// //부터 라인 끝까지 주석으로 처리한다 (행 주석)
/* ~ */ /*와 */ 사이에 있는 모든 범위를 주석으로 처리한다. (범위 주석)

=================================================
자바 프로그램의 구조와 기본 입출력

표준 입출력
화면에 데이터 출력
- println() : ()내부의 내용을 출력한 후 행을 바꾼다.
- print(): ()내부의 내용을 출력만 하고 행은 바꾸지 않는다.
- printf(): 포맷을 지정해서 출력한다.

ex) printf() 형식
System.out.printf(“포맷 명시자”, 데이터, 데이터, …);

키보드로 데이터 입력
- 프로그램의 첫 행에 다음을 추가해 Scanner 클래스의 경로 이름을 컴파일러에 알린다.
import java.uril.Scanner;
- 키보드로 데이터를 입력받으려고 System.in객체와 연결된 Scanner 객체를 생성한다.
Scanner in = new Scanner(System.in);
- Scanner 클래스가 제공하는 다양한 메소드를 이용해 키보드로 데이터를 입력받는다.
inx x = in.nextInt(); // 정수를 읽어 변수 x에 대입한다.

.(온점) 접근연산자로 쓰인다.

변수
변수: 하나의 값을 저장할 수 있는 메모리 공간

첫번째 글자는 문자이거나 ‘$’, ‘_’ 여야 하고 숫자로 시작할 수 없다. (필수)
영어 대소문자가 구분된다. (필수)
첫문자는 영어 소문자로 시작하되, 다른 단어가 붙을경우 첫자를 대문자로 한다. (관례)
자바 예약어는 사용할 수 없다. (필수)
문자 수(길이)의 제한은 없다

변수 표기법
카멜(단봉낙타) 표기법
- 각 단어의 첫 문자를 대문자로 표기하되, 맨 처음 문자는 소문자로 표기
(띄워쓰기 대신 대문짜로 각 단어를 구별함)

파스칼 표기법
- 첫 단어를 대문자로 시작하는 표기법
- 클래스 등에서 사용하는 형태암.
- 기본 표기법에서는 사용하지 않음

====================================
Java는  C와 달리 char가 2byte이다.
Java +연산자는 문자열을 연결해준다.

타입 변환
- 자동 타입 변환: Promotion
- 강제 타입 변환: Casting

큰 크기 타입에다가 작은 크기 타입을 집어넣으면 큰 크기 타입으로 자동으로 된다.
작은 크기 타입에다가 큰 크기 타입을 집어넣으려면 큰 크기 타입 앞에 괄호를 씌우고 작은 크기 타입을 넣는다.
float타입은 값을 넣을 때 값 뒤에 f를 붙여서 명시해준다.

=====================================
System.arraycopy(Objest src, int srcPos, Object dest, int destPos, int length)
src: 원본 배열, srcPos: 복사할 항목의 시작 인덱스, dest: 새 배열, destPos: 붙여넣을 시작 인덱스, length: 복사할 개수

배열 복사
- 참조 타입 배열일 경우, 배열 복사가 되면 복사되는 값이 객체의 번지이므로 새 배열의 항목은 이전 배열의 항목이 참조하는
객체와 동일하다. 이것을 얕은 복사(shallow copy)라고 한다.
- 깊은 복사(deep copy)는 참조하는 객체도 별도로 생성하는 거것을 말한다.

향상된 for문
- 반복 실행을 하기 위해 카운터 변수와 증감식을 사용하지 않는다.
- 배열 및 컬렉션 항목의 개수만큼 반복하고, 자동적으로 for문을 빠져나간다.
- 형식
for(타입 변수 : 배열) {
  실행문;
}

열거 타입 선언
- 열거 타입(enumeration constant): 한정된 값만을 갖는 데이터 타입
- 열거 타입을 선언하기 위해서는 먼저 열거 타입 이름으로 소스 파일(.java)을 생성하야 한다.

열거 타입 변수
- 열거 타입 변수는 열거 상수를 저장할 수 있다.
- 열거 상수는 단독으로 사용할 수 없고, 반드시 열거타입.열거상수로 사용된다.
  ex) 열거타입 변수 = 열거타입.열거상수;
       Week today = Week.SUNDAY;
- 열거 상수는 객체이다.

java.lang.Enum클래스
String name() 열거 객체의 문자열을 리턴
int ordinal() 열거 객체의 순번(0부터 시작)을 리턴
int compareTo() 열거 객체를 비교해서 순번 차이를 리턴
열거 타입 valueOf(String name) 주어진 문자열의 열거 객체를 리턴
열거 배열 values() 모든 열거 객체들을 배열로 리턴

===================================================

객체란
- 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고, 다른 것과 식별 가능 것

- ex) 물리적: 자동차, 자전거, 책, 사람
- ex) 추상적: 학과, 강의, 교과

객체는 속성과 동작으로 구성
- 구성 <-> 필드(field)
- ex) 이름, 나이

- 동작 <-> 메소드(method)
- ex) 달린다, 멈춘다

객체 모델링(Object Modeling)
- 현실 세계의 객체를 소프트웨어 객체로 설계하는 것
- 객체 모델링은 현실 세계 객체의 속성과 작을 추려내어 소프트웨어 객체의 필드와 메소드로 정의하는 과정

객체의 상호작용
- 객체들 사이의 상호작용(데이터를 주고 받는) 수단은 메소드

객체 간의 관계
객체는 개별적으로 사용될 수 있지만, 대부분 다른 객체와 관계를 맺고 있다.
- 집합 관계에 있는 객체는 하나의 부품이고 하나는 완성품
ex) 부품(엔진, 타이어) <- 집합관계 -> 완성품(자동차)
- 사용 관계는 객체 간의 상호작용을 말한다.
(객체는 다른 객체의 메소드를 호출하여 원하는 결과를 얻어낸다.)
ex) 사람 -> 사용관계 -> 사용자
- 상속 관계는 상위(부모)객체를 기반으로 하위(자식)객체를 생성하는 관계를 말한다.
ex) 기계 <- 상속관계 -> 자동차

1. 캡슐화(Encapsulation)
- 실제 구현 내용을 감추는 것
- 외부 객체는 객체내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용
- 필드와 메소드를 캡슐화하여 보호하는 이유: 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다.
- 노출시킬 것인지, 숨길 것인지 -> 접근 제한자(Access Modifier) 사용

2. 상속 (Inheritance)
- 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계 (반복된 코드의 중복을 줄여준다)
- 상속은 상위 객체의 수정으로 모든 하위 객체들의 수정 효과를 가져오므로 유지보수 시간을 최소화 시켜주기도 한다.

3. 다형성
- 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질 
(하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다.)
- 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다.
(부모타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.)
- 다형성의 효과로 객체는 부품화가 가능하다.
ex) 타이어 인터페이스 타입 적용 -> 이 인터페이스를 구현한 실제 타이어들은 어떤 것이든 상관없이 장착(대입)

========================================================
객체와 클래스
- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.
ex) 자동차 객체는 자동차 클래스의 인스턴스이다.

클래스 선언
- 사용하고자 하는 객체를 구상했다면, 그 객체의 대표 이름을 하나 결정하고 이것을 클래스 이름으로 한다.
- 클래스 이름(다른 클래스와 식별할 목적으로 사용)
작성 규칙
1. 하나 이상의 문자로 이루어져야 한다.
2. 첫번째 문자는 숫자가 올 수 없다.
3. $, _ 외의 특수 문자는 사용할 수 없다.
4. 자바 키워드는 사용할 수 없다.

객체 생성과 클래스 변수
- 객체를 생성하는 방법 -> new 연산자를 사용
- new는 클래스로부터 객체를 생성시키는 연산자
- new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다.

클래스의 용도
- 클래스는 두 가지 용도가 있다.
1. 라이브러리(API: Application Program Interface)용
2. 실행용
- 라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다.
- 라이브러리인 동시에 실행 클래스도 만들 수 있다.
- 대부분의 객체 지향 프로그램은 라이브러리와 실행 클래스가 분리되어 있다.

클래스의 구성 멤버
- 필드(객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳)
- 변수: 생성자와 메소드 내에서만 사용, 생성자와 메소드가 실행 종료되면 자동 소멸
- 필드: 클래스 내부 전체에서 사용, 객체가 소멸되지 않는 한 객체와 함께 존재 

생성자
- 생성자는 new 연산자로 호출되는 특별한 중괄호 {} 블록
- 클래스 이름으로 되어 있고 리턴 타입이 없다.
- new 연산자와 같이 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.
- 클래스 내부에 생성자 선언을 생략했다면 컴파일러는 기본 생성자를 바이트 코드에 자동 추가시킨다.
- 클래스가 public class로 선언되면 기본 생성자에도 public이 붙지만,
  클래스가 public없이 class로만 선언되면 기본 생성자에도 public이 붙지 않는다.

필드
- 필드의 고유 데이터, 객체가 가져야 할 부품, 객체의 현재 상태 데이터를 저장하는 곳이다.
- 초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 초기값으로 설정된다.

필드 사용
- 클래스 내부: 단순히 필드 이름으로 읽고 변경
- 클래스 외부: 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용

생성자 오버로딩
- 매개 변수를 달리하는 생성자를 여러 개 선언(매개변수의 타입, 개수, 순서가 다르게 선언)

다른 생성자 호출(this())
- 생성자에서 다른 생성자를 호출할 때 this() 코드를 사용한다.

리턴(return)문
리턴값이 있는 메소드
- return문의 리턴값은 / 리턴 타입이거나 / 리턴 타입으로 변할 수 있어야 한다. -> byte와 short은 int로 자동 변환
- return문을 사용할 때 주의할 점은 return문 이후에 실행문이 오면 Unreachable code라는 컴파일 오류가 발생

리턴값이 없는 메소드
- void로 선언된 리턴값이 없는 메소드에서도 return문을 사용할 수 있다.

인스턴스 멤버
- 인스턴스 멤버: 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드
  인스턴스 필드와 메소드는 (객체에 소속된 멤버이기 때문에)객체 없이는 사용할 수 없다.
  
this
- 객체 외부에서 인스턴스 멤버 접근 -> 참조 변수 사용
- 객체 내부에서 인스턴스 멤버 접근 -> this 사용
this는 주로 (생성자 or 메소드)의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버임을 명시하고자 할 때 사용한다.

정적 멤버와 static
- 클래스의 고정된 멤버 정적(static -> 고정된)
- 정적 멤버는 객체(인스턴스)에 소솓된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.

final 필드
- final 필드: 초기값이 저장 -> 프로그램 실행 도중에 수정할 수 없다.
- final 필드의 초기값을 줄 수 있는 2가지 방법
1. 필드 선언 시에 주는 방법
2. 생성자에서 주는 방법

상수(static final)
- 불변의 값을 저장하는 필드
- final과 상수는 다르다
why? 불변의 값은 객체마다 저장할 필요가 없는 공용성을 띠고 있으며, 여러가지 값으로 초기화 될 수 없기 때문
(final 필드는 객체마다 저장되고 생성자의 매개값을 통해서 여러 가지 값을 가질 수 기 때문)
- 상수는 static이면서 final이어야 한다.
static final 필드는 객체마다 저장되지 않고 클래스에만 포함된다. 그리고 한번 초기값이 저장되면 변경할 수 없다.
===================================================================
인터페이스의 역할
- 자바에서 인터페이스(interface)는 객체의 사용 방법을 정의한 타입이다.
- 인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다.
- 왜 중간에 인터페이스를 두는지 의문
 -> 이유: 개발 코드를 수정하지 않고, 사용하는 객체를 변경할 수 있도록 하기 위해서

인터페이스의 선언
- 인터페이스는 "~java" 형태의 소스 파일로 작성되고 컴파일러(javac.exe)를 통 "~.class"형태로 컴파일되기 때문에 물리적 형태는 클래스와 동일하다.
- 차이점은 소스를 작성할 때 선언하는 방법이 다르다.
- [ public ] interface 인터페이스명 { ... }

1. 상수 필드(constant field)
  인터페이스는 객체 사용 설명서이므로 런타임 시 데이터를 저장할 수 있는 필드를 선언할 수 없다.
  상수 필드는 가능한데, 상수를 선언할 때는 반드시 초기값을 대입해야 한다.
2. 추상 메소드(abstract method)
  추상 메소드는 객체가 가지고 있는 메소드를 설명한 것으로 호출할 때 어떤 매개값이 필요하고, 리턴 타입이 무엇인지만 알려준다.
3. 디폴트 메소드(default method)
  디폴트 메소드는 인터페이스에 선언되지만 사실은 객체(구현 객체)가 가지고 있는 인스턴스 메소드라고 생각해야 한다.
4. 정적 메소드(static method)
  디폴트 메소드와는 달리 객체가 없어도 인터페이스만으로 출이 가능

1. 상수 필드 선언
  인터페이스에 선언된 필드는 모두 public static final의 특성을 갖는다.
  public static final을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.
  인터페이스 상수는 static{} 블록으로 초기화 할 수 없기 때문에 반드시 선언과 동시에 초기값을 지정해야 한다.
2. 추상 메소드 선언
  public abstract를 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다.
  (인터페이스에 선언된 추상 메소드는 모두 PUBLic abstract의 특성을 갖기 때문에)
3. 디폴트 메소드 선언
  public을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다. (디폴트 메소드는 public 특성을 갖기 때문에)
4. 정적 메소드 선언
  public을 생략하더라도 자동적으로 컴파일 과정에서 붙게 된다. (정적 메소드는 public 특성을 갖기 때문에)

인터페이스 구현
- 구현 클래스
public class 구현클래스명 implements 인터페이스명 {
    // 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}

- 구현 클래스에서 인터페이스의 추상 메소드들에 대한 실체 메소드를 작성할 때 주의할 점은 인터페이스의 모든 메소드는 기본적으로 public 접근 제한을 갖기 때문에
public보다 더 낮은 접근 제한으로 작성할 수 없다.
- 만약 인터페이스에 선언된 추상 메소드에 대응하는 실체 메소드를 구현 클래스가 작성하지 않으면 구현 클래스는 자동적으로 추상 클래스가 된다. 따라서 클래스 선언부에
abstract키워드를 추가해야 한다.

인터페이스 구현 객체 사용
- 인터페이스로 구현 객체를 사용하려면 다음과 같이 인터페이스 변수를 선언하고 구현 객체를 대입해야 한다.
인터페이스 변수 = 구현객체;
- 인터페이스 변수는 참조 타입이기 때문에 구현 객체가 대입될 경우 구현 객체의 번지를 저장한다.
===========================================================
익명 구현 객체
- 재사용 -> 구현 클래스 사용
- 일회성 -> 익면 구현 객체 사용

인터페이스 변수 = new 인터페이스() {
    // 인터페이스에 선언된 추상 메소드의 실체 메소드 선언
}

- 중괄호()에는 인터페이스에 선언된 모든 추상 메소드들의 실체 메소드를 작성해야 한다. 그렇지 않으면 에러
- 추가적으로 필드와 메소드를 선언할 수 있지만, 익명 객체 안에서만 사용할 수 있고 인터페이스 변수로 접근할 수 없다.

인터페이스 사용
- 개발 코드에서 인터페이스는 클래스의 필드, 생성자 또는 메소드의 매개 변수, 생성자 또는 메소드의 로컬 변수로 선언될 수 있다.
- 디폴트 메소드 사용
  -> 디폴트 메소드는 인터페이스에 선언되지만, 인터페이스에서 바로 사용할 수 없다.
  -> 디폴트 메소드는 인스턴스 메소드이므로 구현 객체가 있어야 사용할 수 있다. (구현 클래스에 해당 메소드가 없다.)
     [디폴트 메소는 인터페이스의 모든 구현 객체가 가지고 있는 기본 메소드]
  -> 구현 클래스를 작성할 때 디폴트 메소드를 재정의(오버라딩)해서 자신에게 맞게 수정하면 디폴트 메소드가 호출될 때 자신을 재정의한 메소드가 호출된다.이
- 정적 메소드 사용
  -> 인터페이스의 정적 메소드는 인터페이스로 바로 호출 가능하다.

타입 변환과 다형성
- 상속은 같은 종류의 하위 클래스를 만드는 기술
- 인터페이스는 사용 방법이 동일한 클래스를 만드는 기술
개념적 차이점은 있지만, 둘 다 다형성을 구현하는 기술

강제 타입 변환(Casting)
- 구현 객체가 인터페이스 타입으로 자동 변환(자동 타입 변환)하면, 인터페이스에 선언된 메소드만 사용 가능하다는 제약 사항이 따른다.
  -> 경우에 따라 구현 클래스에 선언된 필드와 메소드를 사용해야 할 경우, 강제 타입 변환 후에 구현 클래스의 필드와 메소드를 사용
구현클래스 변수 = (구현클래스) 인터페이스변수;

=================================================================
에러와 예외 클래스
에러: 컴퓨터 하드웨어의 오동작ㄷ 또는 고장으로 인해 응용프로그램 실행 오류가 발생하는 것
예외: 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류a
- 예외가 발생되면 프로그램은 곧바로 종료딘다는 점에서 에러와 동일
- but, 예외는 에러 처리를 통해 프로그램을 종료하지 않고 정상 실행 상태가 유지되도록 할 수 있다.

예외 두 가지 종류
1. 일반 예외(Exception)
- 컴파일 시 예외 처리 코드 검사 (O) (예외 처리 코드가 없으면 컴파일 오류)
    -> 강제적으로 예외 처리 코드 작성 요구
2. 실행 예외(Runtime Exception)
- 컴파일 시 예외 처리 코드 검사 (X)
컴파일 시 예외 처리를 확인하는 차이일 뿐, 두 가지 예외는 모두 예외 처리가 필요

자바에서는 예외를 클래스로 관리한다.
모든 예외 클래스들은 java.lang.Exception 클래스를 상속받는다.

실행 예외
- 만약 개발자가 실행 예외에 대해 예외 처리 코드를 넣지 않았을 경우, 해당 예외가 발생하면 프로그램은 곧바로 종료된다.

자주 발생되는 실행 예외들 [언제 발생되고, 어떤 오류 메시지가 출력되는지 알아둘 필요가 있다.]
1. NullPointerException
2. ArrayIndexOutOfBoundsException
3. NumberFormatException
4. ClassCastException

예외 처리 코드
- 예외 처리 코드: 프로그램에서 예외가 발생했을 경우 프로그램의 갑작스러운 종료를 막고, 정상 실행을 유지할 수 있도록 처리하는 코드
- 예외 처리 코드는 try-catch-finally 블록을 이용한다.
- try-catch-finally 블록은 생성자 내부와 메소드 내부에서 작성되어 일반예외와 실행 예외가 발생할 경우 예외 처리를 할 수 있도록 해준다.

예외 종류에 따른 처리 코드
다중 catch
- catch 블록이 여러 개라 할지라도 단 하나의 catch블록만 실행된다.

catch 순서
- 다중 catch 블록을 작성할 때 주의할 점은 상위 예외 클래스가 하위 예외 클래스보다 아래쪽에 위치해야 한다.

멀티 catch
- 자바 7부터 하나의 catch블록에서 여러 개의 예외를 처리할 수 있도록 멀티catch 기능을 추가했다.
====================================================
예외 떠넘기기
- 경우에 따라 메소드를 호출한 곳으로 예외를 떠넘길 수도 있다.
- Throws 키워드는 메소드 선언부 끝에 작성되어 메소드에서 처리하지 않은 예외를 호출한 곳으로 떠넘기는 역할.
- 떠넘겨진 메소드에서도 try-catch 블록으로 예외를 처리하지 않고 throws 키워드로 다시 예외를 떠넘길 수 있다.
- main() 메소드에서도 throws 키워드를 사용해서 예외를 떠넘길 수 있는데, 결국 JVM이 최종적으로 예외 처리를 하게 된다.
JVM은 예외의 내용을 콘솔에 출력하는 것으로 예외를 처리한다.

main() 메소드에서 throws Exception을 붙이는 것은 좋치 못한 예외 처리 방법이다.
MAIN() 에서 try-catch 블록 내에서 예외를 최종 처리하는 것이 바람직하다.

사용자 정의 예외와 예외 발생
- 사용자 정의 예외[애플리케이션 예외 (Application Exception)]
public class XXXException extends [ Exception | RuntimeException ] {
    public XXXException() {}
    public XXXException(String message) { super(message); }
}

예외 발생시키기
public void method() throws XXXException {
    throw new XXXException("메시지");
}
- 예외 발생 코드를 가지고 있는 메소드는 내부에서 try-catch블록으로 예외를  처리할 수 있지만,
 대부분은 자신을 호출한 곳에서 예외를 처리하도록 throws 키워드로 예외를 처리한다.

예외 정보 얻기
- try블록에서 예외가 발생되면 예외 객체는 catch블록의 매개 변수에서 참조하게 되므로 매개 변수를 이용하면 예외 객체의 정보를 알 수 있다.
- 모든 예외 객체는 exception 클래스를 상속하기 때문에 Exception이 가지고 있는 메소드들을 모든 예외 객체에서 호출할 수 있다.
- 가장 많이 사용되는 메소드는 getMessage()와 printStackTrace()이다.

자바 API 도큐먼트
- API는 라이브러리라고 부르기도 하며, 클래스 및 인터페이스의 모음을 말한다.
- API들은 JDK 설치 경로 > \jre\lib\rt.jar라는 압축 파일에 저장되어 있다.
- API도큐먼트는 쉽게 API를 찾아 이용할 수 있도록 문서화 한 것.

java.lang과 java.util 패키지
- 공통적으로 가장 많이 사용하는 패키지: java.lang, java.util, java.time
* java.lang 패키지
- 자바 프로그램의 기본적인 클래스를 담고 있다.
- java.lang에 패키지에 있는 클래스와 인터페이스는 import 사용할 수 있다.
* java.util 패키지
- 자바 프로그램에 조미료 같은 역할을 하는 클래스를 담고 있다.
- java.util패키지는 컬렉션 프레임워크들이 대부분을 차지하고 있다.
===========================================================
Object 클래스
- 자바의 모든 클래스는 Object 클래스의 자식이거나 자손 클래스이다
- Object는 자바의 최상위 부모 클래스이다.
- 클래스를 선언할 때 extend 키워드로 다른 클래스를 상속하지 않으면 암시적으로 java.lang.Object클래스를 상속받게 된다.
- Object 클래스는 필드가 없고, 메소드들로 구성되어 있다.

* equals() (객체 비교)
- 동일한 객체라면 true를 리턴하고 그렇지 않으면 false를 리턴한다.
Object obj = new Object();
Object obj2 = new Object();

boolean result = obj.equals(obj2);

noolean result = (obj1 == obj2);

Object의 equal() 메소드는 직접 사용되지 않고 하위 클래스에서 재정의 하여 논리적으로 동등 비교할 때 이용된다.
ex) String 객체의 equals() 메소드는 String 객체의 번지를 비교하는 것이 아니고, 문자열이 동일한지 조사한다.

* hashCode() (객체 해시코드)
- 객체 해시코드: 객체를 식별할 하나의 정수값(객체마다 다른 값을 갖고 있다.)
- hashCode()메소드: 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴
- 논리적 동등 비교 시 hashCode()를 오버라이딩할 필요성이 있다.
- 컬렉션 프레임워크의 HashSet.HashMap과 같은 클래스는 두 객체가 동등한 객체인지 판단할 때 아래와 같은 과정을 거침

* toString() (객체 문자 정보)
- Object 클래스의 toString() 메소드: "클래스명@16진수해시코드"로 구성된 문자 정보를 리턴한다.
- Object 하위 클래스는 toString() 메소드를 재정의하여 간결하고 유익한 정보를 리턴
- String 클래스는 toString 메소드를 재정의 해서 문자열을 반환해준다.

System.out.println() 메소드 사용시
- 매개 값이 기본 타입일 경우, 해당 값을 그대로 출력
- 매개값으로 객체를 줄 경우. 객체의 toString()메소드를 호출해서 리턴값을 받아 출력

* clone() (객체 복제)
- 객체 복제: 원본 객체의 필드값과 동일한 값을 가지는 새로운 객체를 생성하는 것
- 객체를 복제하는 이유: 원본 객체를 안전하게 보호하기 위해
(신뢰하지 않은 영역으로 원본 객체를 넘겨 작업할 경우 원본 객체의 데이터가 훼손될 수 있기 때문에)
- Object의 clone() 메소드 자신과 동일한 필드값을 가진 얕은 복제된 객체를 리턴
(이 메소드로 객체를 복제하려면) 원본 객체는 반드시 java.lang.Cloneable 인터페이스를 구현하고 있어야 한다.
- Cloneable 인터페이스를 명시적으로 구현하는 이유: 클래스 설계자가 복제를 허용한다는 의도적인 표시
- Clonable 인터페이스를 구현하지 않으면 clone() 메소드를 호출할 때 CloneNotSupportedException 예외 발생
- clone()은 CloneNotSupportedException예외 처리가 필요한 메소드이므로 TRy-catch 구문이 필요

- 객체 복제 방법
1. 얇은 복제
- 단순히 필드값을 복사해서 객체를 복제하는 것
 - 필드가 기본 타입일 경우: 값 복사
 - 필드가 참조 타입일 경우: 객체의 번지가 복사
2. 깊은 복제

* finalize() (객체 소멸자)
- 필요에 의해 Object의 finalize()를 재정의할 수 있다.
- 한 두 의 객체를 쓰레기로 만들었다고 해서 쓰레기 수집기가 실행되는 것은 아니다.
** System.gc() 호출: 쓰레기 수집기를 가급적 빨리 샐행해 달라고 JVM에 요청

* 쓰개레기 수집기 (참조하지 않는 배열이나 객체를 힙 영역에서 자동적으로 소멸시킨다.)
- 쓰레기 수집기는 객체를 소멸하기 직전에 마지막으로 객체의 소멸자(finalize())를 실행시킨다.
- 쓰레기 수집기는 메모리가 부족할 때, CPU가 한가할 때에 JVM에 의해서 자동 실행된다.
- 쓰레기 객체를 순서대로 소멸시키지 않고 무작위로 소멸시킨다.
- 쓰레기 객체를 전부 소멸시키는 것이 아니라 메모리의 상태를 보고 일부만 소멸시킨다.


